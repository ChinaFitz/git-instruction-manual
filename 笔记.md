[toc]

# Git学习笔记

力求详细的记录Git在日常使用中所需要的操作



## 集中式管理 VS 分布式管理

集中式管理(以SVN为例)

优点: 
-  代码的版本记录存放在统一的服务器上, 有利于项目的管理
-  由于项目的版本控制是集中式储存与管理的, 更加方便代码仓库的权限进行配置
-  SVN服务器中存储的是版本(快照)之间的差异, 存储空间较小

缺点:
- 当服务器出现问题时, 轻则代码版本控制功能暂时无法使用, 重则整个项目的历史记录丢失只留下各个客户端中的最新版本
- 由于快照只储存差异, 所以回滚需要逐个快照进行比对, 速度慢


**SVN的机制描述**: 整个项目的历史快照都保存在服务器中, 而客户端只保存这项目当前最新快照, 所以当服务器出现故障时, 轻则导致由于服务器故障而暂时无法使用版本控制功能, 重则整个项目历史记录丢失, 就算恢复也只能恢复到客户端所拥有的最新快照




---



分布式管理(以Git为例)

优点:
- 每个客户端都储存着整个项目的所有历史快照, 只要客户端还有一个能用就能保证项目的数据(历史记录)不丢失
- Git的每次快照保存, 都是整个项目完整的快照保存, 回滚速度极快

缺点:
- 由于每个快照都是项目完整的历史记录, 所以储存空间会稍微大(但是由于极致的压缩算法空间占用还是很小)


**Git的机制描述**: 项目的完整历史快照(版本)保存在每个客户端中, 服务器也作为其中一个客户端, 每个快照都包含之前的快照以及新增的内容



---

svn与git的储存方式

![](笔记图片/svn与git的储存方式.png)





---
---





## git仓库的文件结构


``` tree
│  config       -> 局部(local)的配置选项文件
│  description  -> 用于显示当前仓库的描述信息
│  HEAD         -> 指向当前所处分支的最新版本
│  logs         -> 保存日志信息, git reflog的信息从这读取
│  index        -> 文件保存暂存区的信息
│  
├─hooks         -> 目录包含客户端或服务端的钩子脚本
│      applypatch-msg.sample
│      commit-msg.sample
│      fsmonitor-watchman.sample
│      post-update.sample
│      pre-applypatch.sample
│      pre-commit.sample
│      pre-merge-commit.sample
│      pre-push.sample
│      pre-rebase.sample
│      pre-receive.sample
│      prepare-commit-msg.sample
│      push-to-checkout.sample
│      update.sample
│      
├─info          -> 包含一个全局性排除文件
│      exclude  -> 作用、用法与.gitignore一致, 不同的是它不会影响团队中的其他人(不上传), 只属于个人的配置
│      
├─objects       -> 存储所有版本数据, 十分重要
│  ├─info
│  └─pack
└─refs  -> 该目录存储着的文件对应不同的分支,文件内容是分支对应的提交对象的hash
    ├─heads
    └─tags
```



---


### 结构中的几个重点的解析

1. HEAD中指向的是refs中heads文件夹中的某个文件, 而heads文件夹中的每个文件代表一个分支, 所以==HEAD指向的是分支(默认是master)==
2. refs文件夹包含heads和tags两个子文件夹
   - heads中的每个文件代表着在git中创建的分支, 其内容是分支对应的最新commit hash
   - tags中每个文件代表着在git中创建的tag, 其内容是tag对应的commit hash
3. index储存着该分支下的所有数据, **除了切换分支外, 在当前分支中index是只增不减的**
4. objects中储存着在不同时期对index进行"打包"而形成的提交对象, 文件夹以hash前两位命名, 文件夹中的文件以hash第3位到最后命名, 文件储存的内容就是每个commit的版本(对象类型是树对象)


